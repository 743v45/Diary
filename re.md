import re
通过re模块实现
可以为想要匹配的相应字符串集制定规则
该字符串集可能包含英文语句，email地址，命令或任何你想搞定的东西
可以问诸如“这个字符串匹配该模式吗？”
你也可以使用RE以各种方式来修改或分割字符串


字符匹配
普通字符
大多数字母和字符一般都会和自身匹配
如正则表达式test会和字符串test完全匹配

元字符
. ^ $ * + ? { } [ ] \ | ( )

[ ]
指定一个字符集 [abc], [a-z]
元字符在字符集中不起作用[akm$]
补集匹配不在区间范围内的字符 [^5]

s = r'^abc'  #匹配行首
s = r'abc$'  #匹配行尾

\ 反斜杠
后面可以加不同的字符以表示不同特殊意义
也可以用于取消所有的元字符 \[ 或\\
r = r'\^abc'  #转义。

\d  匹配任何十进制数，它相当于类[0 - 9]
\D  匹配任何非数字字符，它相当于类[^0 - 9]
\s  匹配任何空白字符，它相当于[\t\n\r\f\v]
\S  匹配任何非空白字符，它相当于[^\t\n\r\f\v]
\w  匹配任何字母数字字符，它相当于类[a-zA-Z0-9_] 
\W    匹配任何非字母数字字符，它相当于类[^a-zA-Z0-9_] 

*
指定前一个字符可以被匹配零次或更多次，而不是只有一次，匹配引擎会试着重复尽可能多的次数（不超过整数界定范围 20亿）
或者'\d{8}'

+ 至少出现一次
？ 重复0 或 1 次

{m,n}
其中m和n是十进制整数。该限定符的意思是至少有m个重复，至多到n个重复。a/{1,3}b
忽略m会认为下边界是0，而忽略n的结果将是上边界为无穷大（实际上是20亿）
{0,}等同于*，{1，}等同于+ 而{0,1}则与？相同。如果可以的话，最好使用*+？

p = re.compile('ab*')
可以把正则表达式编译成对象
p.findall('abbbb')
csvt_re = re.compile(r'csvt', re.I)  #为了不考虑大小写.

match()  决定RE是否在字符串刚开始的位置匹配
search() 扫描字符串，找到这个RE匹配的位置
findall()  找到RE匹配的所有子串，并把它们作为一个列表返回
finditer()  找到RE匹配的所有子串，并把它们作为一个迭代器返回
如果没有匹配到的话，match()和search() 将返回None
如果有的话，就返回一个MatchObject


group  返回被RE匹配的字符串
start  返回匹配开始的位置
end 返回匹配结束的位置
span  返回一个元祖包含匹配{开始，结束}的位置

>>>rs = r'c..t'
>>>re.sub(rs, 'python','csvt caat cvvt cccc')
'python python python cccc'
把 'c..t' 格式的全部替换成'python'
>>>re.subn(rs, 'python','csvt caat cvvt cccc')
'python python python cccc' , 3
多了一个数字，表示更改次数

>>>ip = '1.2.3.4'
>>>ip.split('.')
['1', '2', '3', '4']
>>>s = '123+4134*123-123'
>>>re.split(r'[\+\-\*]',s)






